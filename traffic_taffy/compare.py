"""The primary statistical packet comparison engine."""

from __future__ import annotations
from typing import List, TYPE_CHECKING
from logging import error

if TYPE_CHECKING:
    from traffic_taffy.dissection import Dissection
    from traffic_taffy.comparison import Comparison
    from traffic_taffy.config import Config
    from argparse import ArgumentParser, Namespace

from traffic_taffy.dissectmany import PCAPDissectMany
from traffic_taffy.algorithms.statistical import ComparisonStatistical
from traffic_taffy.algorithms.comparecorrelation import CompareCorrelation


class PcapCompare:
    """Take a set of PCAPs to then perform various comparisons upon."""

    def __init__(
        self,
        pcap_files: List[str],
        config: Config,
    ) -> None:
        """Create a compare object."""
        self.config = config
        self.pcap_files = pcap_files
        self.deep = config.get("deep", True)
        self.maximum_count = config["packet_count"]
        self.pcap_filter = config["filter"]
        self.cache_results = config["cache_pcap_results"]
        self.dissection_level = config["dissection_level"]
        # self.between_times = config["between_times"]
        self.bin_size = config["bin_size"]
        self.cache_file_suffix = config["cache_file_suffix"]
        if self.cache_file_suffix[0] != ".":
            self.cache_file_suffix = "." + self.cache_file_suffix
        self.ignore_list = config["ignore_list"]
        self.layers = config["layers"]
        self.force_overwrite = config["force_overwrite"]
        self.force_load = config["force_load"]
        self.merge_files = config["merge"]
        self.filter_arguments = config["filter_arguments"]

        algorithm = config["algorithm"]

        algorithm_arguments = {
            "timestamps": None,
            "match_string": self.filter_arguments["match_string"],
            "match_value": self.filter_arguments["match_value"],
            "minimum_count": self.filter_arguments["minimum_count"],
            "make_printable": True,
            "match_expression": self.filter_arguments["match_expression"],
        }

        if algorithm == "statistical":
            self.algorithm = ComparisonStatistical(
                **algorithm_arguments,
            )
        elif algorithm == "correlation":
            self.algorithm = CompareCorrelation(
                **algorithm_arguments,
            )
        else:
            error(f"unknown algorithm: {algorithm}")
            raise ValueError()

    @property
    def pcap_files(self) -> List[str]:
        """List of pcap files being compared."""
        return self._pcap_files

    @pcap_files.setter
    def pcap_files(self, new_pcap_files: List[str]) -> None:
        self._pcap_files = new_pcap_files

    @property
    def reports(self) -> List[dict]:
        """List of reports generated by the comparison."""
        return self._reports

    @reports.setter
    def reports(self, newvalue: List[dict]) -> None:
        self._reports = newvalue

    def load_pcaps(self, config: Config) -> None:
        """Load all pcaps into memory and dissect them."""
        # load the first as a reference pap
        pdm = PCAPDissectMany(
            self.pcap_files,
            config,
        )
        return pdm.load_all()

    def compare(self) -> List[Comparison]:
        """Compare each pcap as requested."""
        dissections = self.load_pcaps(self.config)
        self.compare_all(dissections)
        return self.reports

    def compare_all(self, dissections: List[Dissection]) -> List[Comparison]:
        """Compare all loaded pcaps."""

        self.reports = self.algorithm.compare_dissections(dissections)
        return self.reports


def compare_add_parseargs(
    compare_parser: ArgumentParser, config: Config, add_subgroup: bool = True
) -> ArgumentParser:
    """Add common comparison arguments."""

    config.setdefault("only_positive", False)
    config.setdefault("only_negative", True)
    config.setdefault("print_threshold", 0.0)
    config.setdefault("top_records", None)
    config.setdefault("reverse_sort", False)
    config.setdefault("sort_by", "delta%")
    config.setdefault("algorithm", "statistical")

    if add_subgroup:
        compare_parser = compare_parser.add_argument_group("Comparison result options")

    compare_parser.add_argument(
        "-t",
        "--print-threshold",
        default=config["print_threshold"],
        type=float,
        help="Don't print results with abs(percent) less than this threshold",
    )

    compare_parser.add_argument(
        "-P",
        "--only-positive",
        action="store_true",
        help="Only show positive entries",
        default=config["only_positive"],
    )

    compare_parser.add_argument(
        "-N",
        "--only-negative",
        action="store_true",
        help="Only show negative entries",
        default=config["only_negative"],
    )

    compare_parser.add_argument(
        "-R",
        "--top-records",
        default=config["top_records"],
        type=int,
        help="Show the top N records from each section.",
    )

    compare_parser.add_argument(
        "-r",
        "--reverse_sort",
        action="store_true",
        default=config["reverse_sort"],
        help="Reverse the sort order of reports",
    )

    compare_parser.add_argument(
        "-s",
        "--sort-by",
        default=config["sort_by"],
        type=str,
        help="Sort report entries by this column",
    )

    compare_parser.add_argument(
        "-A",
        "--algorithm",
        default=config["algorithm"],
        type=str,
        help="The algorithm to apply for data comparison (statistical, correlation)",
    )

    # compare_parser.add_argument(
    #     "-T",
    #     "--between-times",

    return compare_parser


def get_comparison_args(args: Namespace) -> dict:
    """Return a dict of comparison parameters from arguments."""
    return {
        "maximum_count": args.packet_count or 0,
        "print_threshold": float(args.print_threshold) / 100.0,
        "minimum_count": args.minimum_count,
        "match_string": args.match_string,
        "match_value": args.match_value,
        "only_positive": args.only_positive,
        "only_negative": args.only_negative,
        "top_records": args.top_records,
        "reverse_sort": args.reverse_sort,
        "sort_by": args.sort_by,
        "merge_files": args.merge,
        "algorithm": args.algorithm,
        "match_expression": args.match_expression,
    }
